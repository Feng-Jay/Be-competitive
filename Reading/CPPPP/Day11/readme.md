# C++中的代码重用

前面介绍的公有继承就是实现代码重用的机制之一, 但并不是唯一的机制. 本文将介绍其他方法, 其中之一是使用这样的类成员: **本身是另一个类的对象. 这种方法称为包含/组合/层次化**. 另一种方法是使用 **私有/保护继承.**通常, 包含与私有/保护继承用于实现`has-a`关系, 即新的类将包含另一个类的对象. **多重继承使得能够使用两个或多个基类派生出新的类, 将基类的功能组合在一起.**

**以及类模板--使用通用术语定义类然后用模板来创建针对特定类型的特殊类.**

## 包含对象成员的类

*介绍: C++的valarray类是一个用来表示数组的类, 支持对数组中的元素进行求和/最大/最小等操作*

*Example:*

```cpp
valarray<int> q_values;
valarray<double> weights;

double gpa[5] = {1,2,3,4,5}
valarray<double> v1;
valarray<int> v2(8); //an array of 8 elems
valarray<int> v3(10, 8); //an array of 8 elems, each is 10
valarray<double> v4(gpa, 4); // first 4 elems of array gpa.
valarray<double> v5 = {1,2,3,4,5}; //c++11

operator[]; //access by index
size(); // num of elems
sum(); // sum of elems
max(); // max elem
min(); // min elem
```

### A example class

```cpp
class Student{
  private:
  	string name;
  	valarray<double> scores;
  ...
};
```

上述实现将数据成员声明为私有的, 那么只有Student类的成员函数可以使用string 和 valarray<double> 类的公有接口来访问和修改name和scores对象. 但在类外不能这样做, 只能通过Student的公有接口访问name和scores.

**这种情况被称为Student 类只获得了成员对象的实现, 而没有继承接口. ** 举例来说, 就是string类有operator+定义, 但Student并没有天生就继承到.

*不继承接口是has-a关系的组成部分.*

如果我们想实现的话, **需要在Student类中定义相应成员函数, 在成员函数中调用对象的接口**

### 实现一个包含类的细节

*Tips: `typedef`在类的private中使用意味着可以在该类中使用它, 在其他类中无法使用.*

#### 初始化被包含对象

对于内置类型的变量:

```cpp
Queue::Queue(int qs): qsize(qs){...}
```

对于派生对象的基类部分, 调用基类的构造函数:

```cpp
hasDMA::hasDMA(const hasDMA& hs): baseDMA(hs){...}
```

对于成员对象, 继续使用成员名字:

```cpp
Student:: Student(const char* str, const double * pd, int n): name(str), scores(pd, n){}
```

列表中的每一项都是一个与之匹配的构造函数.

**如果不使用列表初始化会怎么样呢?**

C++要求在构建对象的其他部分前, **先构建继承对象的所有成员对象.**因此, 如果省略列表初始化, C++将使用成员对象所属类的默认构造函数.

*初始化顺序: 当初始化列表包含多个项目时, 项目被初始化的顺序是他们在类中声明的顺序, 而不是初始化列表中排放的顺序. 如果代码使用一个成员的值为另一个成员的初始化表达式的一部分时顺序就很重要了!!!*

#### 使用被包含对象接口

被包含的对象接口不是公有的, 但可以在类方法中使用它.

## 私有继承

私有继承是另一种实现`has-a`关系的途径. 私有继承: 基类的公有成员和保护成员都将成为派生类的私有成员. 意味着基类方法将不会成为派生对象公有接口的一部分, 但可以在派生类的成员函数中使用它们.

*使用公有继承, 继承类对象会有基类对象的公有方法, 这是`is-a`关系的一部分; 使用私有继承, 基类的公有方法将成为继承类的私有方法, 这是`has-a`关系的一部分.*

**使用私有继承, 类将继承实现:** 例如从`String类`派生出`Student类`, 后者将有一个`String类`组件用于保存字符串, 且可以使用方法. **包含对象将一个命名的成员对象添加到类中, 而私有继承将对象作为一个未命名的继承对象添加到类中.**

### A Example(new version)

```cpp
class Student: private std:: string, private std::valarray<double>
{
  public:
  ...
}
```

使用多个基类的继承被称为多重继承(MI), 后续会介绍MI的一些问题. 

#### 与包含方式的区别

1. Student类不需要私有数据, 因为两个基类已经提供了所需的所有数据成员. (两个无名子对象成员)

2. 初始化不同:

   ```cpp
   Student::(const char* str, const double* pd, int n): name(str), scores(pd,n){}
   
   // new
   Student::(const char* str, const double* pd, int n): std::string(str), ArrayDb(pd,n){}
   ```

   继承类, 新版本的构造函数将使用成员初始化列表语法, 但使用类名而非成员名来标识构造函数.

3. 访问基类的方法:

   ```cpp
   // old
   double Student::average() const{
     if (scores.size() > 0)
       return scores.sum()/socres.size();
    	else
       return 0;
   }
   
   // new
   double Student::average() const{
     if(ArrayDb::size() > 0)
       return ArrayDb::sum() / ArrayDb::size();
     else
       return 0;
   }
   ```

   使用私有继承时将使用类名和作用域解析符来调用方法

4. 访问基类对象

   对于包含成员的类, 我们可以通过类中定义公有方法来返回`string name;`但对于私有继承中无名的对象, 该怎么做呢?

   **答案是强制类型转换, 因为Student类是从string类派生的, 因此可以通过强制类型转换将其转换为string对象.**

   ```cpp
   const string& Student:: Name() const{
     return (const string&) *this;
   }
   ```

5. 访问基类的友元函数

   同样也是将类型显式转换为基类的类型就可以了. 在私有继承中, 未进行显式类型转换的派生类引用或指针无法赋给基类的引用或指针.

## Discussion: 使用包含还是私有继承

大多数C++使用者倾向包含: 

1. 易于理解 
2. 继承会带来很多问题, 尤其是MI, 比如同名方法的独立基类或者共享祖先的独立基类. 
3. 包含可以有多个同类的对象, 而继承只有一个.

但私有继承能够提供的特性比包含多: 

1. 假设类包含保护成员, 则这样的成员在派生类中是可用的, 但在继承层次结构外是不可用的. 包含并不是派生, 因此无法使用保护成员. 但继承得到的是派生类, 能够访问保护成员.
2. 需要重新定义虚函数.派生类可以重新定义虚函数, 但包含不行. 使用私有继承, 重新定义的函数只能在类中使用, 而不是公有的.

### 保护继承

使用保护继承时, 基类的公有成员和保护成员都将成为派生类的保护成员. 基类的接口在派生类中可用, 在继承层次外不可用. 但当从 **派生类派生出另一个类时私有继承和保护继承的区别就体现出来了:** 私有继承第三代无法使用基类的接口; 保护继承时在第三代仍可使用.

**可用using 重新定义访问权限**

使用保护/私有派生时, 基类的公有成员将变为保护/私有成员. 如何让基类方法在派生类外可用? 方法一是定义一个使用基类方法的派生类方法. 另一种方法**: 将函数调用包装在另一个函数调用中, 即使用一个using声明, 指出派生类可以使用特定的基类成员, 即使采用的是私有派生.**

**using声明只使用成员名: 没有返回类型, 圆括号, 函数特征标**

## 多重继承

MI描述的是有多个直接基类的类, 公有MI表示的也是`is-a`关系, 必须用public来限定每一个类, 否则默认为private.

两个问题:

### 从两个或更多相关基类继承同一个类的多个实例

**Example:**

```cpp
class worker
{  };
class Waiter : public worker{};
class Singer : public worker{};

class SingingWaiter: public Waiter, public Waiter{};
```

`Singer`和`Waiter`都继承类一个Worker组件, 因此SingingWaiter将包含两个worker组件. 这将引起**二义性**的问题:

```cpp
SingingWaiter ed;
Worker * pw = & ed;
```

因为ed中包含两个worker对象, 有两个地址可供选择, 所以应该使用类型转换来指定对象:

```cpp
worker* pw1 = (Waiter*) &ed;
worker* pw2 = (Singer*) &ed;
```

但问题的根本是 **我根本不需要两个worker的对象, 我为什么要徒增烦恼呢?** 为此, C++提出来 **虚基类**

虚基类使得从多个类派生出的对象只能继承一个基类对象, 例如在类声明中使用关键字`virtual`, 可以使worker成为singer和waiter的虚基类:

```cpp
class Waiter : virtual public worker{};
class Singer : public virtual worker{};

class SingingWaiter: public Waiter, public Waiter{};
```

此时二者共享一个worker对象, 而不是各自的副本.

为什么不全变成虚的? 因为1. 在一些情况下需要基类的多个拷贝 2. 作为虚的需要额外的计算 3. 也有缺点:

使用虚基类时 **需要对类构造函数采用一种新的方法**

对于非虚基类: 构造函数的初始化列表中基类构造函数可以传递: 即从派生类到基类的基类再到基类的基类的基类...

但对于虚基类, **这种信息自动传递失效**

因为自动传递消息时会有多条可以选择的途径, 为了避免冲突C++禁止将信息通过中间类自动传递给基类. **需要显式调用基类的构造函数**

```cpp
SingingWaiter(const & wk, int p = 0, int v = Singer::other): worker(wk), Waiter(wk,p), singer(wk, v){}
```

对于虚基类必须这么操作, 但对于非虚基类这样做是非法的!

### 从两个不同基类继承同名方法

对于多继承, 每个直接祖先可能都有一个名字相同的函数, 对于派生类如果没有定义自己的函数那么会造成调用的二义性.

可选的方法有: 1. 把基类和每个中间类新增的数据成员分别用一个函数打印出来, 最后在MI的派生类中调用.

2. 将所有数据组件都设置为保护的而不是私有的. 但数据安全保护没有private的高.

### 混合使用虚基类和非虚基类

加入B被用作C,D的虚基类; 同时被作为X,Y的非虚基类. 而M是从C,D,X,Y派生而来的. 这种情况下: M从C,D继承类一个B类子对象; 从X,Y分别继承了一个B类子对象. 所以该类有 **一个表示所有虚途径的基类子对象和分别表示各条非虚路径的多个基类子对象.**

### 虚基类和支配

如果不使用虚基类, 那么如果派生类从不同类中继承到了相同名称的成员,如果没有加类名以限定就使用 会有二义性.

如果使用虚基类, 这样做不一定会导致二义性. **如果某个名称优于其他所有名称, 则使用它. 如果没有谁更优, 那就还是会导致二义性**

**派生类中的名称优先于直接或间接祖先类中的相同名称.**

**Example:**

```cpp
class B
{
  public:
  	short q();
};
class C: virtual public B
{
  public :
  	long q();
  	int omg()
};
class D: public C{...};
class E: virtual public B
{
  private:
  	int omg();
};
class F: public D, public E
{
  ...
};
```

这样, C中的q()定义优先于B中的q()定义.

F中的方法可以用q()来表示C::q()

任何一个omg()都不优先于其他的omg()

**虚二义性规则与访问规则无关(public和private, protected)**

### summary

虚基类带来的主要变化是: 从虚基类的一个或多个实例派生而来的类将只继承了一个基类对象. 为实现该特性必须满足:

1. 有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数, 对于间接非虚基类来说是违法的.
2. 通过优先规则解决二义性.

MI带来的复杂度主要是派生类通过多条途径继承同一个基类引起的. 避免该情况后唯一需要注意的就是: 在必要时对继承的名称进行限定.

## 类模板

继承和包含并不总能满足 重用代码的需求, 例如 Stack和Queue类都是容器类. 专门用于存储其他对象/类型. 

模板提供参数化类型, 能够将 **类型名作为参数传递给接收方来建立类或函数.**

### 定义模板类

模板类以下面的代码作为开头:

```cpp
template <class Type>
// or
template <typename Type>
```

其中class/typename 看作变量的类型名, 把Type看作该变量的名称. **当变量被调用时, Type将被具体的值(int, string等)代替.**

同业在实现类方法时, 每个函数头都要以相同的模板声明开头.

```cpp
template <class T>
bool Stack<T>:: push(const T & elem){...}
```

**如果在类声明中定义了方法, 那么可以省略模板前缀和类限定符.**

**注意: 这些模板不是类和成员的定义, 他们是C++编译器指令, 说明如何生成类和成员函数定义.模板的具体实现被称为实例化/具体化**. 不能将模板的成员函数放在独立的实现文件中. 由于模板不是函数, 他们不能单独编译. 最简单的方法是将所有模板信息放在一个头文件中, 并在使用模板的文件中包含该文件.

### 使用模板类

模板类的实例化必须显式提供类型, 但函数模板可以根据参数类型确定生成的函数:

```cpp
Stack<int> s1;
```

在模板声明中可以使用`Stack`作为函数的返回值, 等价于`Stack<Type>`但只能在类声明中使用, 在类外实现函数时仍需要加上<TYPE>

### 非类型参数

Example: 允许指定数组大小的数组模板.

实现方法1: 在类中使用动态数组和构造函数参数来提供元素数目

实现方法2: 使用模板参数来提高常规数组大小. 下面就是实现的例子

```cpp
template<class T, int n>
class Array
{
  private:
  	T a[n];
  ...
};
```

模型后的int n参数被称为非类型/表达式参数.

如果有这样的声明 `Array<int, 12> a1;`就会创建一个长度为12的int数组.

**但表达式参数有一定的限制: 可以是整形/枚举/引用/指针类型, 因此double类型是不合法的, 但double* 是合法的.** 另外模板代码 **不能修改参数的值, 但不能使用参数的地址, 实例化模板时用作表达式参数的值必须是常量表达式.**

非类型参数的优点: 构造函数法使用的是new和delete管理的堆内存, 而表达式法使用的是栈内存, 速度更快.

非类型参数的缺点: 非类型参数方法中每种数组都会生成自己的模板 将生成很多个独立的类声明. 但使用构造函数法只会创建一个类声明, 并将大小信息传递给类的构造函数, 因此也更加通用, 因为是成员数据之一, 可以将一种尺寸的数组赋给另一种尺寸的数组.

### 模板的多功能性

#### 递归使用模板

```cpp
Array<Array<int ,5>, 10> twoarray; <==> int two[10][5];
```

#### 使用多个类型参数

模板可以包含多个类型参数.

```cpp
template<class T1, class T2>
class a
{
  
};
```

#### 默认类型模板参数

```cpp
template <class T1,class T2=int>
```

可以为模板类提供默认值, 但不能为函数模板参数提供默认值. 可以对非类型参数提供默认值.

### 模板具体化

隐式实例化: 即通过声明特定类型的对象, 编译器会生成相应的类定义

```cpp
array<double, 20> a1;
```

但编译器在需要对象前不会生成隐式实例化:

```cpp
array<double, 20> * pt; // donot
pt = new array<double, 20>; //generated
```

**显式实例化**

#### 成员模板

#### 模板用作参数

#### 模板类和友元

#### 模板别名







