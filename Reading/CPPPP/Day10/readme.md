# 类继承

## Why we need this?

面向对象编程的主要目的之一是提供可重用代码, 在C中, 厂商提供专用的函数库, 但这种方法是有局限的: 如果厂商不给出源码, 无法根据自己需求对其进行扩展修改, 即使提供源码, 也会有影响整个工程的风险.

C++类提供了类库, 其包含了数据表示和类方法, 内容更加完整且可以从已有的类中派生出新的类, 派生类 **继承**了原有类的特征和方法, 可以: 在已有类的基础上添加新功能, 给类添加新数据, 修改类方法的行为...

**A example:**

```cpp
class RatedPlayer : public TableTennisPlayer
{
  ...
};
```

上面的代码表明`RatedPlayer`类的基类是`TableTennisPlayer`,后者是一个公有基类, 该行为称为公有派生. 

**派生类对象包含基类对象**, 使用公有派生, 基类的公有成员变为派生类的公有成员; 基类的私有部分也称为派生类的一部分, **但只能通过基类的公有和保护方法访问**

## Why that is useful?

我们来看继承做了什么:

* 派生类对象存储了基类的数据成员
* 派生类对象可以使用基类的方法

我们还需要做什么:

* 派生类需要自己的构造函数(给新成员和继承的成员提供数据)
* 派生类可以根据需要添加额外的数据成员和成员函数

## how to use?

### 构造函数: 访问权限考虑

`派生类不能直接访问基类的私有成员, 必须使用基类的方法进行访问`, **所以派生类的构造函数必须使用基类的构造函数**

也就是说派生类创建对象前程序首先创建基类对象:

```cpp
DerivedClass:: DerivedClass(unsigned int r, const string & fn, const string & ln, bool ht):
BaseClass(fn, ln, ht)
{
  newmember = r;
}
```

该构造函数首先执行`BaseClass`创造一个基类对象将值存在该对象里, 然后将新值存在该对象里面.

如果不调用基类构造函数, 将使用默认的基类构造函数

释放对象的顺序和创造对象的顺序相反: 首先执行派生类的析构函数, 再使用基类的构造函数.

### 派生类与基类的特殊关系

1. 派生类可以使用基类的方法(方法不是private)
2. 派生类的指针可以在不显式类型转换的基础上指向派生类对象
3. 派生类的引用可以在不显式类型转换的基础上引用派生类对象

**基类指针和引用只能用于调用基类方法, 不可以将基类对象和地址赋给派生类引用和指针**

*some tips:*

*1. 函数参数为基类引用/指针的参数可以传入派生类对象*

*2. 可以把基类对象初始化为派生类对象* `Base temp (derived);`

*3. 也可以把基类派生对象赋给基类对象*`Base temp = derived;`

## Design philosophy

`is-a relationship`

C++有3种继承方式: 公有/保护/私有继承. 公有继承最常用, 建立了一种`is-a`关系.即派生类对象也是一个基类对象, 可以对基类对象执行任何的操作也可以在派生类上执行. 而不是后面要提到的`has-a, is-like-a, is-implemented-as-a, uses-a`关系.

Example:

```cpp
Fruit -> Banana // is-a 
Lunch -> fruit  // has-a
Shark -> Lawter // is-like-a lawer like shark
Array -> Stack  // is-implemented-as-a use array to implement stack
Computer -> Printer // use-a
```

在C++完全可以使用继承实现其他的关系, 但为了设计哲学的妥协, 最好还是使用`is-a`

***

## polymorphism(多态)

如果希望同一个方法在派生类和基类中的行为是不同的, 即方法的行为应该取决于调用方法的对象, 这种行为被称为`多态`, 即同一个方法的行为随上下文而异, 有 **两种实现的机制**:

1. 在派生类中重新定义基类的方法
2. 使用虚方法

Example:

```cpp
BaseClass{
  private:
  	int data1;
  	string name;
  public:
  	BaseClass(...);
  	virtual int func1();
  	virtual void func2();
  	void showname();
  	virtual ~BaseClass(){};
}

DerivedClass{
  private:
  	int data1;
  	int newdata;
  	string name;
  public:
  	DerivedClass(...);
  	virtual int func1();
  	virtual void func2();
  	void newfunc();
}
```

可以看到`BaseClass 和 DerivedClass`分别声明了两个`virtual`开头的方法, 这些方法被称为虚方法

而且`BaseClass`也声明了一个虚析构函数, 即使其没有任何操作.

下面我们来看看这些行为的作用体现在哪里:

1. 如果方法是通过引用或指针而非对象调用的, virtual方法和普通方法在方法的选择上有差异. 如果没有使用关键字`virtual`程序将根据引用/指针类型来选择方法; 如果使用了`virtual`关键字, 程序将根据引用/指针指向的对象的类型来选择方法.

*方法在基类中声明为虚的后他在派生类中将自动成为虚方法, 但使用virtual指出也是一个好习惯*

这样做是因为在实际中我们往往会使用一个数组来统一管理`BaseClass`和`DerivedClass`两种类型的对象, 在这时, 虚函数就可以确保执行我们想要的函数.

2. 许析构函数是为了确保释放派生对象时, 程序按照正确的顺序调用析构函数. 如果析构函数不是虚的, 则将只调用指针类型的析构函数, 将会导致内存泄露.

*virtual 只用于类声明的方法原型中, 在实现方法时不需要*

*Tips: 非构造函数不能使用成员列表初始化语法*

## Static Binding and Dynamic Binding

程序调用函数时将使用哪个可执行代码块呢? 编译器将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编. 在编译过程中进行联编被称为`静态联编`, 然而虚函数的出现使程序在编译时无法确定用户将使用哪种类型的对象, 因此, 编译器必须能生成`在程序运行时选择正确的虚方法的代码, 被称为动态联编`

动态联编和通过指针和引用调用方法相关. 将派生类引用或指针转换为基类引用或指针被称为向上强制转换, 这使公有继承**不需要进行显式类型转换**(is-a关系的一部分), 向上强制转换是可传递的. 而向下强制转换必须使用显示转换否则不被允许 **因为is-a关系是不可逆的**

因此, 隐式的向上强制转换使基类指针或引用可以指向基类对象或者派生类对象, 因此需要动态联编, C++使用虚函数满足这种需求.

### question1: why 2 methods of Binding? Why default method is static Binding?

这样的设计有效率和概念两方面的考量.

首先, 为了能够使程序在运行时进行决策, 动态联编采取了一些方式来跟踪基类指针/引用指向的对象, 增加了额外的处理开销. 且如果类不用做基类/派生类不对方法做重新定义, 也不需要动态联编. C++的原则就是 **不为不使用的特性付出代价**

在概念模型上, 设计类时可能包含一些不在派生类重新定义的成员函数, 不将其设置为虚函数首先效率更高, 其次可以明确指出不需要重新定义的函数.

### question2: how do they work?

编译器处理虚函数的方法是: 给每个对象添加一个隐藏成员, 隐藏成员中保存了一个指向函数地址数组的指针.

该数组被称为 **虚函数表** 虚函数表中存储了为类对象进行声明的虚函数地址.例如: 基类对象包含一个指针, 该指针指向基类中所有虚函数的地址表. 派生类对象将包含指向一个独立地址表的指针, 如果派生类提供了虚函数的新定义, 该虚函数表将保存新函数的地址; 如果没有重新定义虚函数, 则保存函数原始版本的地址; 如果派生类定义了新的虚函数, 则该函数地址也会被加入表中. 

**无论类中包含的虚函数是多少个, 只需要在对象中添加一个地址成员, 只是表的长度不同**

在调用虚函数时, 程序将查看存储在对象中的虚函数表地址, 然后转向相应的函数地址表.

我们可以看到, 虚函数带来的成本包括三方面:

1. 对象都将增大, 增大量为一个存储地址的空间
2. 对每个类, 编译器都需要创建一个虚函数地址表
3. 对每个函数调用, 都需要从表中查找地址.

### Something about virtual functions

一些要点:

* 在基类方法的声明中使用`virtual`可以使方法在基类以及所有派生类中是虚的
* 如果使用指针或引用来调用虚方法, 程序将使用对象类型定义的方法 *动态联编*
* 如果定义的类用作基类, 那么应将那些要在派生类中重新定义的方法声明为虚的

1. 构造函数不能是虚函数. 创建派生类对象时将调用派生类的构造函数, 然后派生类的构造函数将调用积累的构造函数. 该顺序**不同于继承机制**, 因此**派生类不继承基类的构造函数**
2. 析构函数应该是虚函数, **即使基类不需要显式析构函数提供服务也不应该依赖于默认析构函数, 而应该提供虚析构函数**
3. 友元不能是虚函数, 因为友元不是类成员, 而只有成员才能是虚函数.
4. 如果派生类没有重新定义函数, 将使用函数的基类版本; 如果派生类位于派生链中, 则应使用最新的虚函数版本.
5. **重新定义将隐藏方法**:

Example:

```cpp
Class Base{
  private:
  	...
  public:
  	virtual void method1(int a) const;
};
Class Derived{
  private:
  	...
  public:
  	virtual void method1() const;
  	...
};
```

**The above codes cause some problems.** 上述代码将基类中接受一个int类参数的函数method1()重新定义为一个不接受参数的函数. 

**但重新定义并不会生成函数的两个重载版本, 而是隐藏了接受一个int参数的基类版本**.  **重新定义继承的方法并不是重载, 如果重新定义派生类的函数, 将不只是将使用相同的函数参数列表覆盖基类声明, 无论参数列表是否相同, 基类的所有同名方法都会被隐藏.**

`两条经验`:

1. 如果重新定义基类的方法, 应确保与原来的原型完全相同, 但如果返回类型是基类指针/引用, 则可修改为只想派生类的引用和指针(该特性被称为返回类型协变), 允许返回类型随类型的变化而变化
2. 如果基类声明被重载了, 这应该在派生类中重新定义所有的基类版本:

```cpp
// Example of 2.
class Base{
  public:
  	virtual void m1(int a)const;
  	virtual void m1(double x) const;
  	virtual void m1() const;
};
class Derived{
  public:
  	virtual void m1(int a) const;
  	virtual void m1(double x) const;
  	virtual void m1() const;
} 
```

**如果只重新定义一个版本, 其他两个版本将被隐藏, 派生类无法使用他们**

哇. 你会不会觉得这样很麻烦, 但如果其他版本不需要修改的话, 我们可以使用这样的`捷径`:

```cpp
void Derived:: m1() const{ Base:: m1();}
```

## 访问控制: protected

`protected`和`private`相似, 在类外只能用公有类成员来访问`protected`部分中的成员; `private`和`protected`的区别在派生类中才会表现出来, 派生类的成员可以直接访问基类的保护成员, 但不能直接访问基类的私有成员. **对于派生类来说, 保护成员的行为与公有成员相似**

*最好对类数据成员采用私有访问控制, 不要使用保护访问控制; 同时通过基类方法使派生类能够访问基类数据* 但对于成员函数来说, 保护访问控制很有用, 可以让派生类能够访问公众不能使用的内部函数.

## 抽象基类 ABC

有时候使用`is-a`规则并不是那么容易, 例如正在开发图形程序, 有两个类`Ellipse`和`Circle`(椭圆和圆), 因为所有圆都是椭圆, 我们直观地认为可以从`Ellipse`派生出`Circle`, 但其中有很多问题: 椭圆中很多数据和方法(长短半轴, 角度, 旋转等内容对于圆来说都是多余的)

这就引出了抽象基类: 可以从`Ellipse`和`Circle`类中的共性, 将这些特性放在一个ABC中, 然后从ABC中派生出`Ellipse`和`Circle`类, 但在实现ABC的时候可能会遇到这样的问题:

ABC中有派生类共同需要的函数成员, 但并没有包含需要的数据成员, 这该怎么办呢?

C++ 使用**纯虚函数**来提供未实现的函数:

```cpp
class ABC{
  private:
  	...
  public:
  	virtual double Area() const = 0;
  	...
};
```

**当类中包含纯虚函数时, 不能创建该类的对象**, 这里的理念是: 包含纯虚函数的类只用作基类. 

但C++ **也允许纯虚函数有定义**, 可以在实现文件中提供方法定义, **总之在原型中使用`=0`指出类是一个抽象基类, 在类中可以不定义该函数**

## Inherit and dynamic memory alloc

继承如何与动态内存分配进行结合呢? 如果基类使用动态内存分配 并重新定义赋值和构造函数, 派生类该如何呢?

### 1. 派生类不使用new

可以直接使用系统默认的构造函数, 复制构造函数, 赋值 和析构函数. 派生类默认的这些函数都会自动调用基类的相应函数然后加上新添加的数据(无new).

### 2. 派生类使用new

**必须为派生类定义显示的析构函数, 复制构造函数和赋值运算符**

派生类的析构函数会自动调用基类的析构函数, 所以只需要显式对派生类构造函数执行的工作进行清理:

```cpp
Derived:: ~Derived(){
  delete [] newadded;
}
```

派生类的复制构造函数可以调用基类的复制构造函数(会使用派生类的基类部分构建新对象):

```cpp
Derived:: Derived(const Derived& d): Base(d)
{
  deep copy new added elems;
}
```

派生类的复制运算符:

```cpp
//Base class' op=
Base& Base::operator=(const Base& r)
{
  if (this == &rs)
    return *this
  delete [] lable; // lable is a pointer data member of Base
  label = new char[std::strlen(r.label) + 1];
  std::strcpy(lable, r.label);
  return *this;
}

//Derived class' op=
Derived& Derived::operator=(const Derived& r)
{
  if (this == &r)
    return *this;
  Base::operator=(r);// copy Base content
  delete [] new_label;
  new_label = new char[std::strlen(r.new_label)+1];
  std::strcpy(new_label, r.new_label);
  return *this;
}
```

**很奇怪的一个语句: `Base::operator=(r);`** 其实等价于 `*this = r`但调用Base的赋值运算符. 但实际中会导致递归调用, 所以这个样的一个函数调用语句很好地解决了这个问题.

**总之, 当基类和派生类都使用动态内存分配时, 派生类的析构/复制构造函数, 赋值预算符都必须使用相应的基类方法来处理基类元素. 对于析构函数是自动的, 对于构造函数需要手动列表初始化时调用基类构造函数, 对于赋值运算符需要显式调用基类的赋值运算符完成.**

### 派生类如何访问基类的友元?

```cpp
class Base{
  ...
  public:
  	friend std::ostream& operator<<(std::ostream& os, const Base& r);
};

class Derive{
  ...
 	public:
  	friend std::ostream& operator<<(std::ostream& os, const Derive& r);
}
```

```cpp
std:: ostream& operator<<(std::ostream& os, const Derive& r){
  os<<(const Base&) r;
  os<< r.new_elem<<endl;
  return os;
}
```

作为Derive类的友元当然可以访问其成员函数, 但他并不是Base类的友元, 这里使用 **强制类型转换来匹配原型找到对应函数**这里是使用Base类的友元函数.

## 类设计回顾

### 编译器自动生成的成员函数

* 默认构造函数: 要么没有参数, 要么参数都有默认值. 其主要是为了确保对象的正确初始化, 要做的主要工作是:1. 调用基类的构造函数 2. 调用数据成员是对象的构造函数.

* 复制构造函数: 接受其所属类的对象作为参数, 在

  1. 将新对象初始化为一个已有对象 

  2. 将对象按值传入函数 

  3. 将对象按值返回 

  4. 编译器生成临时对象的情况下**会调用该函数**. 

     **默认的该函数是执行浅拷贝**, 但在有new/static的情况下应该自己实现.

* 赋值运算符: 用于同类对象间赋值, **注意与初始化区分, 只有创造一个新对象时使用初始化, 如果修改一个已有对象值叫赋值**

  如果需要显式构造复制构造函数, 也应该定义赋值运算符.原型如下:

  ```cpp
  Star& Star::operator=(Star& r);
  ```

  编译器不会自动声明在两个类对象之间的赋值运算符, 可以通过**声明不同类型的复制运算符**或使用 **转换操作**:将其他类型转换为star类型, 然后使用上述的赋值运算符. 

  前一种方法速度快但代码多, 后一种方法可能导致compiler出现混乱.

### 其他的类方法

* 构造函数: 它创建新的对象而其他方法是被现有对象调用的, 这是构造函数不会被继承的原因: **继承意味着派生类对象可以使用基类的方法, 但在构造函数完成前对象并不存在.**

* 析构函数: **对于基类, 即使它不需要析构函数也应该提供一个新的虚析构函数**

* 转换: **使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换.** 例如:

  ```cpp
  // Star的构造函数原型, 分别将 char* 和C1 转换为 Star类型
  Star(const char *);
  Star(const C1&, int members = 1); 
  
  //Usage
  Star north;
  north = "Polaris";
  // 第二条语句调用了 Star:: operator=(const Star*)函数, 使用Star(const char*)生成一个Star对象.
  ```

  可以使用`explicit`关键字禁止进行隐式转换, 仍允许显式转换:

  ```cpp
  ...
  explicit Star(const char*);  
  ...
    
  Star north;
  north = "Polaris"; //Not allowed
  north = Star("Polaris"); //Allowed
  ```

  **实现将类对象转换为其他类型, 应定义转换函数:** 可以是没有参数的类成员函数, 也可以是返回类型被声明为目标类型的类成员函数. 即使没有声明返回类型, 也应该返回所需的返回值.

  ```cpp
  Star::operator double() {};
  Star::operator const char* (){};
  ```

  但应该理智使用, 避免二义性:

  ```cpp
  Vector ius(6.0, 0.0);
  Vector iux = ius + 20.2;
  ```

  这里可以将ius变为double然后做加法 或者将20.2转换为Vector然后使用vector加法. **需要使用`explicit`加以限制**

* 按值传递和按引用传递对象

  传引用的原因: 

  1. 提高效率(按值传递需要生成一个临时对象, 调用了很多类成员函数) 且如果不修改对象尽量传const

  2. 在继承使用虚函数时, 被定义为接受基类引用参数的函数可以接受派生类.

* 返回对象和返回引用

  返回引用不返回对象的原因: 返回对象涉及一个临时副本生成, 代价大

  但并不是总能返回引用, 函数不能返回在函数执行过程中创建的临时对象的引用, 因为函数结束后会销毁.

* 使用const

  使用const可以确保方法不会修改参数:`Star::Star(const char* s){...}`

  可以确保方法不会修改调用它的对象:  `void Star::show() const{...}`, 这个const代表`const Star *this`

  通常可以将返回引用的函数调用放在表达式左侧, 意味着可以将值赋给引用的对象, 但可以使用const来确保引用或指针的返回值不会修改原对象: `const Star& name(...){...}`

  **如果函数参数声明为指向const的指针或引用, 只有另一个函数也确保不修改参数时才能传递.**

## 公有继承的考量

1. 遵循`is-a`关系. 如果派生类不是一种特殊的基类则不要使用公有派生. `is-a`关系的方式之一是无需进行显式类型转换, 基类指针就可以指向派生类对象/ 引用可以引用派生类对象. 反过来不行.
2. 什么不能继承? 构造函数: 创建派生类对象时会调用基类的构造函数. C++11给出了一个可以继承构造函数的机制, 但默认扔不继承. 析构函数: 释放对象时会调用基类的析构函数. 赋值运算符: 派生类继承的方法的特征标与基类完全相同, 但赋值运算符的特征标随类而异, 因为包含一个类型为其所属类的参数.
3. 赋值运算符. 如果对象属于派生类, 将调用基类的赋值运算符来处理基类部分的内容.
4. 私有成员和保护成员. 对于派生类而言, 保护成员类似公有成员. 对外部而言, 保护成员类似私有成员. **使用私有数据成员比保护数据成员更好, 但保护方法很有用**
5. 虚方法. 如果希望派生类能够重新定义方法, 则应该在基类中将方法定义为虚的, 这样可以启用动态联编. 
6. 析构函数. 基类的析构函数应该是虚的. 这样可以确保使用基类指针/引用删除对象时可以正确调用析构函数.
7. 友元函数. 非成员函数不能继承, 但可以使用强制类型转换调用基类的友元.
8. 使用基类方法的说明:
   * 派生类对象自动使用继承来的基类方法(如果没有重定义的话)
   * 派生类构造函数自动调用基类构造函数. 如果没有初始化列表中指定的话调用默认构造函数.
   * 派生类方法可以使用作用域解析符来调用公有的和受保护的基类方法.
   * 派生类友元函数可以通过强制类型转换调用基类友元函数.

## Summary

继承通过使用已有的基类定义新的类, 使得能够根据需要修改编程代码. 公有继承建立is-a关系, 意味着派生类对象也应该是某种基类对象.

派生类可以继承基类的数据成员和大部分方法, 但不能继承基类构造函数/析构函数/赋值运算符. 派生类可以访问基类的公有/保护成员, 并通过基类的公有/保护方法访问基类的私有成员.

如果希望派生类可以重新定义基类的方法, 可以使用关键字virtual声明虚函数. 基类的析构函数通常应该是虚的.
