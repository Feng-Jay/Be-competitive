# 词典

逻辑上的词典: 一组数据组成的集合, 其中各元素都是关键码和数据项合成的词条. map与dict的区别: map要求不同词条的关键码互异; dict允许多个词条有相同的关键码.二者统称为符号表, 不要求词条间能够根据关键码比较大小. 

以散列表为代表的符号表结构, 转而依赖数据项的数值来做逻辑查找和定位, key与value的地位等同, “循值访问”, 适用范围更广. **不再属于CBA式算法, 也不再服从CBA算法复杂度下界, 高效算法得以实现.** 

跳转表允许同时包含多个关键码雷同的词条; 散列表则不允许.

## 跳转表

vector和list各有所长: 前者便于静态查找, 但动态维护成本高; 后者便于增量式动态维护, 但只支持顺序查找. 因此前面提出了二叉搜索树, 但结构较复杂; 引入跳转表的目的是为了找到一个简便直观的方法完成该任务.  **查询和维护在平均意义下仅需O(logn)时间**

总体逻辑为: 内部按横向分层, 纵向相互耦合的多个列表组成{S0, S1, S2, ..., Sh}组成, h称为跳转表高度.

S0与Sh称为底层和顶层, 同层节点间有前驱后驱关系, 纵向也可以定义. 

**高层列表总是低层列表的子集, S0包含所有词条, Sh不含任何词条**

### 四联表

按上述约定, 跳转表内部各节点沿水平和垂直方向都可定义前驱和后继, 支持该连接方式的表叫四联表.

### 查找

算法: 
> 从顶层列表的头节点出发, 向右向下查找目标关键码k
> 在每一层, 从前向后找, 直到找到key > k
> 回退一步, 判断是否相等, 相等则返回
> 否则, 若到底层, 失败;
> 否则, 转至当前塔的下一节点.

**空间复杂度** : 根据“生长概率逐层减半”条件, 总体空间消耗的期望值应为O(n)

**时间复杂度** : search的单次纵向/横向跳转本身只需要常数时间, 故查找所需时间应取决于横向,纵向跳转的总次数. 其时间复杂度期望值不超过O(logn)

### 插入

在最底层查找到应该插入的位置, 然后随机令该新塔上长.

时间复杂度O(logn)

### 删除

在查找到该词条后, 依次删除塔顶.  时间复杂度O(logn)

## 散列表

只要**散列函数**, **散列表**, **冲突排解方案合理**, 散列技术可以在常数时间内实现词典的所有接口操作.(与词典规模无关)

### 完美散列

**散列表**

hashtable是散列表的底层逻辑, 由一系列可存放词条的单元组成. 故这些单元也称为bucket/桶单元. 各桶单元也按照逻辑次序在物理上连续排列. 常用数组来实现, 桶数组. 

**散列函数**

一组词条在hashtable内部的具体分布取决于hashing方案——事先在词条和桶地址间约定的某种映射关系(从关键码到桶地址的函数):

<center>hash(): key -> hash(key)</center>

hash()为散列函数, hash(key)为key的散列地址(即在散列表中的秩)

当可以在O(1)时间确定散列地址, 每一个桶恰好存一个学生的学籍词条, 没有重复和空余, 这样在时间和空间性能取得最优的散列称为**完美散列**. 但完美散列并不常见.

对于这样的情况: 尽管词典中实际需要保存的词条数目N远远少于可能出现的词条数目R, 但R个词条中的任何一个都有可能出现在词典中. 会导致空间利用率很低, 将非空桶的数目和桶单元总数的比值称为装填因子, 上述问题的实质就是在于散列表的装填因子太小, 导致空间利用率低.

### 散列函数设计

假定关键码均为[0, R)范围内的整数, 将词典中的词条数记作N, 散列表长度记作M, 通常有: R >> M > N

**因此, hash函数的作用可理解为, 将关键码的空间[0,R)压缩到散列的地址空间[0,M)**

**设计原则**:

> 1. 具有确定性, 词条E在散列表中的映射地址hash(E.key)必须取决于其关键码key.
> 2. 映射过程不能太复杂, 保证散列地址计算可快速完成, 从而保证查询/修改操作整体的O(1)执行时间
> 3. 所有关键码经映射后应尽量覆盖整个地址空间[0,M). hash()最好是满射.

因为R>>M, 所以hash()不可能是单射, 这就意味着**关键码不同的词条也会存在被映射到同一散列地址的情况**——称为散列冲突, 难以彻底避免. 虽然后续可以有解决方案, 但如果hash函数设计更为细致或充分, 便可尽可能降低冲突发生的概率.

**因此最重要的原则就是**
> 4. 关键码映射到各桶的概率尽量接近于1/M.

将关键码空间“均匀地”映射到散列地址空间, 从而避免极端低效的情况出现.

**随机性越强, 规律性越弱的散列函数越好**

1. 除余法

将散列表的长度M取为素数, 并将关键码key映射至key关于M整除的余数: hash(key) = key mod M

**采用除余法时必须将M选为素数, 否则关键码被映射到[0,M)范围内的均匀度将大幅降低, 发生冲突的概率将随着M所含素因子的增多而迅速加大.**

2. MAD法

以素数为表长的除余法仍有一定的问题: 从关键码到地址空间的角度来看, 依然有连续性. 比如: 关键码相邻对应的散列地址总是相邻的. 极小的关键码, 通常都映射到散列表的起始区段, 特别的“0”是一个不动点, 散列地址总是0.

为弥补这一不足, 可使用MAD法将关键码KEY映射为:

(axkey + b) mod M, 其中M仍为素数, a>0, b>0 且 a mod M ≠ 0

因为需要乘法, 加法, mod, 因此命名为MAD法

更多的散列函数:

* 从关键码key中取特定的若干位

* 平方取中法: 从key的十进制/二进制展开中取中间的若干位, 构成一个整数地址.