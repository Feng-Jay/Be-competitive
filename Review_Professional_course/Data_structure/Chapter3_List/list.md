# 列表

向量中各数据项的物理存储位置和逻辑次序完全照应, 可以通过秩来直接访问对应的元素. 但列表中元素的**物理地址可以任意**

列表元素之间在前驱和后继元素之间应该维持某种索引关系, 该索引关系可被理解为元素的位置,故列表元素是“循位置访问”/“循链接访问”.

*向量中的秩同时对应于逻辑和物理次序，而位置仅对应于逻辑次序.*

## 从向量到列表

### 静态2动态

数据结构的操作可分为静态和动态两类: 前者仅从中获取信息; 后者则会修改数据的局部/整体. 

在向量中, `size(), get()`等静态操作可以在常数时间内完成, `insert(), remove()`等动态操作却可能需要线性时间. **其原因是向量采取了静态存储策略: 各元素物理地址连续**.

而列表对物理地址无任何限制, 即采用了**动态存储策略**. 对于动态操作可大大降低成本.

### 秩2位置

对数据结构的访问应该与其存储策略一致, 列表中按秩访问的效率很低, 应更多地习惯用位置来代指并访问动态存储结构的数据元素.

## 列表

### 头尾节点

List内部有私有的header和trailer, 对外并不可见. 对外可见的数据节点若存在, 则第一个和最后一个分别称作首节点(first node)和尾节点(last node).

header 和trailer的存在使得每个节点都存在前驱和后继元素, 带来很大便利.

## 排序器

### 插入排序

始终将整个序列视作并切分为两部分:有序的前缀，无序的后缀;通过迭代，反复地将后缀的首元素转移至前缀中.

**在任何时刻，相对于当前节点e = S[r]，前缀S[0, r)总是业已有序**

最优时间复杂度为O(n), 最差时间复杂度为O(n^2), 平均时间复杂度为O(n^2)

### 选择排序

与插入排序类似, 将序列划分为无序前缀和有序后缀两部分.此外，还要求前缀不 大于后后缀。如此，每次只需从前缀中选出最大者，并作为最小元素转移至后缀中，即可使有序部分的范围不断扩张。

无论输入序列如何, 需要的时间复杂度均为O(n^2), 因此与插入排序算法不同，该算法的时间复杂度为固定的。也就是说，其最好和最坏情况下的渐进效率相同。

选择排序属于**CBA算法**, 其时间消耗主要在寻找最值的过程中, 我们可以使用更高级的数据结构降低该过程为O(logn), 将整体排序算法的时间复杂度降低到O(nlogn)

### 归并排序

其复杂度应为O(nlogn)

向量与列表归并排序算法之间存在细微但本质的区别。前者 支持循秩访问的方式，故可在O(1)时间内确定切分中点;后者仅支持循位置访问的方式，故不 得不为此花费O(n)时间。幸好在有序子序列的合并阶段二者均需O(n)时间，故二者的渐进时间依旧相等.


