# 搜索树

先前的`vector`和`list`无法同时满足高效率地查找和动态调整, 其线性结构造成了限制.  因此提出`树式查找`

## 查找

查找即: 从一组数据对象中找出符合条件者, 其中的数据对象叫做`词条`; 不同词条间依靠各自的关键码`key`进行区分. 

查找的过程和结果, 仅仅取决于目标对象的`key`, 该方式为循key访问.

因此词条的数据结构定义如下:

```cpp
template <typename K, typename V> struct Entry { //词条模板类
    K key; V value; //关键码、数值
    Entry ( K k = K(), V v = V() ) : key ( k ), value ( v ) {}; //默认构造函数
    Entry ( Entry<K, V> const& e ) : key ( e.key ), value ( e.value ) {}; 
    //基于克隆的构造函数
    bool operator< ( Entry<K, V> const& e ) { return key < e.key; } 
    //比较器:小于
    bool operator> ( Entry<K, V> const& e ) { return key > e.key; } 
    //比较器:大于
    bool operator== ( Entry<K, V> const& e ) { return key == e.key; } 
    //判等器:等于
    bool operator!= ( Entry<K, V> const& e ) { return key != e.key; } 
    //判等器: 不等于
}; //得益于比较器和判等器，从此往后，不必严格区分词条及其对应的关键码
```
根据重载的操作符来看, 词条的判等和比较操作即为关键码的判等和比较操作. 当然在某些情况下, 词条之间的比较可能没有现实意义/在一些追求高效的场合并不需要所有元素间都可以比较, 只关心个别元素.

## Binary Search Tree

BST具有顺序性: `任一节点r的左(右)子树中, 所有节点均不大于(不小于)r`, 即左子树节点都<=r, 右子树节点都 >= r. 

因此其中序遍历的结果一定是一个`非降序序列`

### 查找算法

减而治之,其过程为: 从根节点出发, 逐步缩小查找范围, 直到发现目标(成功)或缩小至空树(失败)

即一旦发现当前节点为null则说明查找范围为空, 查找失败; 否则, 视关键码比较结果, 小于则向左深入|大于则向右深入|相等则报告成功. 

因此, 可以看出, 查找算法的复杂度主要 `取决于树的高度`, 因此`平衡二叉搜索树`的提出也具有了很大的意义.

### 插入算法

为了在二叉树插入节点, 首先用`search`算法确定插入的位置及方向, 然后将新节点作为叶子插入.然后更新插入节点及其祖先的高度信息.

效率: 时间消耗主要在`search`算法和`updateHeightAbove`算法上面, 每层至多调用一个节点, 因此其**效率也取决于新节点的深度, 最坏情况下不超过全树的高度**

### 删除算法

当删除只有左孩子/右孩子的节点时, 用其孩子代替该节点即可. 若删除一个双子节点, 那么需要用`succ`算法找到其直接后缀, 然后将其二者交换, 删除该后继节点即可. **该后继节点一定无左孩子**, 然后更新节点的高度即可.

