# 串

串作为数据结构有以下特点: 1. 结构简单  2. 规模庞大 3. 元素重复率高

## 串

一般的, 由n个字符组成的串记作: S = "a0, a1, ..., an-1", 其中ai属于∑, 0 ≤ i ≤ n. ∑为所有可用字符的集合, 称为字符表. 

字符串S所含的字符总数n称作S的长度, 记作|S| = n. 长度为0的串称为空串.

字符串中任一连续的片段称作其子串. 有两种特殊的子串: 起始于位置0, 长度为k的子串称为前缀; 终止于位置n-1 长度为k的子串称为后缀. 

**结论**

> 空串是任何字符串的子串/前缀/后缀. 
>
> 任何字符串都是自己的子串/前缀/后缀
>
> 这种子串/前缀/后缀称为 平凡子串/前缀/后缀
>
> 字符串本身之外的所有非空子串/前缀/后缀, 称为真子串/前缀/后缀

## 串匹配

模式匹配是字符串应用中最常用的操作, 可以将问题描述为: `如何在字符串数据中, 检测和提取以字符串形式给出的某一局部特征`, 这类操作都属于串模式匹配.

### 蛮力算法

将文本串固定, 模式串与文本串首对齐. 自左向右逐一对比: 若当前字符对相互匹配, 则转向下一字符; 一旦失败, 将模式串右移一个字符, 然后从首字符开始与文本串当前位置重新对比.

```cpp
int match(char* P, char* T)
{
  size_t n = strlen(T), i = 0;
  size_t m = strlen(P), j = 0;
  while(j<m && i<n){
    if(T[i] == P[j]) {i++; j++;}
    else {i-= j-1; j=0;}
  }
  return i-j;
}
```

```cpp
int match(char* P, char* T)
{
  size_t n = strlen(T), i = 0;
  size_t m = strlen(P), j = 0;
  for(i = 0; i < n -m +1; ++i){
  	for(j=0; j < m; ++j){
    	if(T[i+j] != P[j]) break;
    }
    if (j>=m) break;
  }
  return i;
}
```

蛮力算法至多迭代(n-m+1)次, 每次至多比较m次. 因此最坏的时间复杂度为`O(m(n-m-1))`渐进时间复杂度为O(mn)

### KMP算法

蛮力算法的问题在于, 存在着大量的局部匹配: 每一轮对比中, 仅有最后一次失败, 但一旦发现失败, 就要再从头开始一次匹配. 有很多次匹配是没有必要之前已经做过的.

实际上, 指针i完全不必回退. **记忆 == 经验 == 预知力**, 利用以往成功的对比, 不仅可以避免文本串指针的移动, 而且可以使模式串尽可能大跨度向右移. 

#### next表

假设前一轮对比终止于T[i]≠P[j], 按以上构想, 指针i不必回退, 将T[i]与P[t]对齐开始下一轮匹配, 那么t是?

>  前一轮匹配确定: P[0, j) = T[i-j, )
>
> 若P经适当右移后, 能与T的某一子串完全匹配, 则必要条件为: P[0,t) = T[i-t, i) = P[j-t, j)

所以 **在P[0,j)**中长度为t的前缀应与长度为t的后缀完全匹配: `N(P, j) = { 0 ≤ t < j | P[0, t) = P[j - t, j) }`

一般集合中会有多个t, 且其中具体由哪些t值组成, **仅取决于模式串P和前一轮对比的首个失败位置P[j], 与文本串无关**

相当于, 将P右移了j-t个单元, 位移量其实是和t成反比的. 因此, 为保证P与T的对齐位置绝不倒退且不遗漏任何可能的匹配, 在N(P,j)中选择最大的t. 令:

`next[j] = max(N(P,j))`

**一旦发现P[j]与T失配, 即可转将P[next[j]]与T[i]彼此对准, 从这一位置开始下一轮匹配**

可通过预处理先计算出所有位置j对应的next[j]值, 然后反复查询, `记忆力 <==> 预知力`

#### KMP算法

```cpp
int match(char* P, char* T)
{
  int* next = buildnext(P);
  int n = strlen(T), i = 0;
  int m = strlen(P), j = 0;
  while(i<n && j<m){
  	if(0>j ||	T[i] == P[j]) {i++; j++;}//匹配或P已经移出最左侧
    else j = next[j]
  }
  delete [] next;
  return i-j;
}
```

可以看到, 相比蛮力算法只是在处理失配的情况下有所不同, 这也是KMP精髓所在.

不难看出, 只要j>0, 就一定有0属于N(P,j); 但若j=0, N(P,j)为ø, 该如何定义next[j=0]呢?

在字符串匹配过程中, 假如首字符就不匹配, 就应该直接将P右移一个字符, 然后启动下一轮对比, 可以假设在P[0]左侧有一个P[-1], 该字符与任何字符都是匹配的, 等同于令next[0] = -1

**若已知next[0,j], 如何才能递归地计算出next[j+1]?**

若next[j] = t, 则意味着在P[0, j) 中, 自匹配的真前缀和真后缀的最大长度为t, 故必然有next[j+1] ≤ next[j]+1 且只有P[j] = P[t]时会取等号. 

那么, 若P[j]≠P[t]时, 又该如何得到next[j+1]?

此时, 需要反复调用next数组, 即 next[next[j]] +1, next[next[next[j]]]+1, ...

反复用next[t]替换t, 直到发现P[j]和P[t]匹配, 即令next[j+1] = next[t] + 1, 最后即时t降低到0, 也会终止于通配的`-1`. 

```cpp
int* buildNext(char*P)
{
  size_t m = strlen(P), j = 0;
  int* N = new int [m];
  int t = N[0] = -1;
  while(j<m-1){
    if(0 > t || P[j] == P[t]){
      j++; t++;
      N[j] = t;
    }else{
      t = N[t];
    }
  }
  return N;
}
```

该方法等价于模式串的自我模式匹配. KMP算法的复杂度为O(n+m): m为构造next数组时间

### 继续改进

**记忆==教训==预知力**

之前提出的next表的作用是利用以往**成功**的对比提供的经验来预知未来; 然而, **失败**的对比作为教训同样有用.

例如P="000010", next = -1, 0, 1, 2, 3, 0. 在匹配过程中, 如果P[3]失配了, 还会继续匹配P[2],P[1],P[0]..., 重蹈覆辙.

因此修改`N(P,j) = {0≤t< j | P[0,t)=P[j-t,j)且P[t]≠P[j]}}`

即除了"对应于自匹配长度"外, t同时还需要满足"当前字符对不匹配"的必要条件, 才能纳入next表的候选.

```cpp
int* buildNext(char*P)
{
  size_t m = strlen(P), j = 0;
  int* N = new int [m];
  int t = N[0] = -1;
  while(j<m-1){
    if(0 > t || P[j] == P[t]){
      j++; t++;
      N[j] = P[j]!=P[t] ? t : N[t];
    }else{
      t = N[t];
    }
  }
  return N;
}
```



