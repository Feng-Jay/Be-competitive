**这是一个用来记录读书和lab过程中遇到的知识点和问题的Notebook!**

# 第二章 信息的表示和度量

1. `char`是有符号还是无符号？

大多认为是有符号的，但c标准中不保证这一点
`arm-linux-gcc 规定 char 为 unsigned char; vc 编译器、x86上的 gcc 规定 char 为 signed char`.

标准中提供了char, signed char 和unsigned char三种类型

2. 大多intel机器为小端序。但目前大多处理器为双端序，由具体os来确定真正是大端还是小端

在网络数据流传输，阅读数据，进行强制类型转换(引用对象)时有影响。

3. P39, 使用 bis and bic 实现c的boolean

```c
int bool_or(int x, int y){
    int result = bis(x,y);
    return result;
}

int bool_xor(int x, int y){
    int result = bis(bic(x,y),bic(y,x));
    //bic(x,y) y=1时x清零
    //bic(y,x) x=1时y清零
    //剩下的地方是x自己为1或0/y自己为1或0的地方
    //二者的公共为1的地方全是0了
    //所以这些地方不可能出现同1的情况，所以只可能是0/1，0/0
    // 只要出现1，就可以置为1
    // 所以外面使用一个bis嵌套即可
}
```

4. c语言中若移位数>数据本身位数会发生什么情况？

**Undefined behavior**, 一般情况下移位数为`k mod w`, 但并不保证。 应当避免此类情况。

5. 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式。

6. c默认常量都是有符号的, 可加上后缀`u``U`表示无符号。

7. c中，若一个运算数是有符号的而另一个是无符号的，那么c语言会隐式地将所有符号参数强制转换为无符号的。

这对于一些**逻辑**运算来说影响很大！！！

8. 数值位宽的改变和从有符号->无符号的顺序是会影响程序结果的，c语言中规定先进行位宽改变，再进行符号转换。

例：

```cpp
short i = -1;
unsigned int res = i;
cout << res<<endl;
//4294967295 先符号扩展，再符号转换
//若反过来，则仍为1
```

9. 截断

无符号数从w位截断为k位: x'= x mod 2^k

有符号数从w位截断为k位: x'= 补码解读(x mod 2^k)

10. suggestion: 不要使用unsigned定义非负数

可能使用场景: 

    1. 表示1bit向量

    2. 用作mask

    3. 表示地址

    4. 高精度数学包

11. 两个w位的无符号数字相加最大为w+1位；两个w位的有符号数相加也可能需要w+1位。

判断是否溢出：

```cpp
//unsigned 
bool ov(unsigned int x, unsigned int y){
    unsigned int s = x+y;
    return s < x;
}
bool ov(int x, int y){
    int s = x + y
    return ((x<0 == y<0) && (x<0 != s<0)) || ((x>0 == y>0) && (x>0 != s>0));
}
```

```cpp
//wrong case
int tadd_ok(int x, int y){
    int sum = x+y;
    return (sum-x == y)&&(sum-y == x);
}
//模数加法和无符号数字构成了一个阿贝尔群
//所以(x+y)-x=y & (x+y)-y=x 一定成立 
```

判断减法是否溢出:

```cpp
//wrong case
int tsub_ok(int x, int y){
    return taddok(x, -y);
}
```
该算法除了当y==Tmin时错误外都会给出正确值。

当y == Tmin时, -y = Tmin 

taddok会认为只有当 x<0 时才溢出, 此时返回0

但实际应该当x > 0时, 减法会溢出返回0
x< 0时不会溢出返回1

12. 补码的非 
~x+x=-1 <==>  
~x+1 = -x

13. 判断乘法是否溢出

```cpp
int mult_ok(int x, int y){
    int p = x*y;
    return !x || p/x==y;
}
```

为什么加法不能用减法证明但却可以用除法验证乘法是否溢出呢？

考虑w位的 x,y,p,q; p为x和y的补码乘法结果，q为p/x的结果:

(1) x · y = p + t2^w (t≠0 iff p is ov)

(2) p = x · q + r (|r| < |x|)

(3) 联立(1),(2)可得 q == y iff t=r=0

14. 除以2的幂的补码除法

需要加上一个bias来修正不合适的舍入

(x+y-1)/y 然后向下舍入

15. IEEE浮点表示

用`V = (-1)^s*M*2^E`表示一个数

* 符号: s决定数字为负数还是正数

* 尾数: M是一个二进制小数, 范围是1～2-e, 或者是 0~1-e

* 阶码: E的作用是对浮点数加权, 权重是2的E次幂(可能是负数)

****

* 一个单独的符号位`s`直接编码s

* k位的阶码字段exp=ek-1,...,e0编码E

* n位的小数字段frac= fn-1,...,f0编码尾数M，但编码出的值也依赖于阶码字段的值是否为0

float类型中: s 1bit, k 8bits, n 23bits

double类型中: s 1bit, k 11bits, n 52bits

**情况1: 规格化的值**

最普遍情况，**exp的位模式既不全为0也不全为1**.

阶码字段exp被解释为以bias表示的有符号整数。即 E=e-bias

(bias是一个等于2^k-1的值,即float=127,double=1023)

因此**阶码值范围为**: float[-126,127], double[-1022,1023]

小数字段frac被解释为描述小数值f(0≤f<1), 其二进制表示为0.fn-1,...,f0;

尾数定义为1+f <==> f.fn-1,...,f1,f0

**情况2: 非规格化的值**

当阶码域全为0时，所表示的数是非规格化形式。

阶码值 E= 1 - bias

尾数的值 M=f, 即小数字段的值, 不包含隐含的开头的1

作用: 

* 提供了表示数值0的方法

0.0: 符号位是0, 阶码字段全为0, 小数域也全为0; 当符号位为1时而其他域全为0时，得到值-0.0.

* 表示非常接近0.0的数字

提供逐渐下溢的属性, 可能的数值分布均匀地接近于0.0

**特殊值**

当阶码全为1时出现的。当小数域全为0时，得到的数值表示无穷, 当s=0时代表正无穷; s=1时代表负无穷。

当小数域为非零时，结果值被称为"NAN"(Not a Number)

**浮点数在数轴上的分布并不是均匀的, 越靠近原点处它们越稠密**

16. 舍入

向偶舍入(很好地避免了统计偏差): 当值并非处于中间值时，四舍五入; 若为中间值，则将其最低有效位舍入为偶数。

向零舍入; 向下舍入; 向上舍入

17. 浮点运算

**浮点加法没有结合律！！！**

**浮点乘法也没有结合律，没有分配律**



