# 编译器优化的限制
编译器只能对程序进行`安全的优化`, 也就是说优化后的程序和优化前的程序有一样的行为. 要求程序员编写出编译器`能够优化的代码`.

例如:

```cpp
void twiddle1(long* xp, long* yp){
    *xp+=*yp;
    *xp+=*yp;
}
void twiddle2(long* xp, long* yp){
    *xp+= 2* *yp;
}
```
二者似乎有相同的行为, 且似乎`twiddle2`的效率更高一些(3次io:r *xp, r *yp, w *xp), 而前者需要6次io。

但如果`xp==yp`时:

```cpp
//twiddle1
*xp+=*xp;
*xp+=*xp; //xp的值增加4倍
//twiddle2
*xp+=2* *xp; //xp的值增加3倍
```
两个指针可能指向同一内存区域的情况称为`内存别名使用`. 在执行安全的优化中, 编译器无法将其进行从1->2的优化。

**内存别名使用限制了编译器优化的策略**, 第二个妨碍优化的因素是**函数调用**:

```cpp
long f();

long func1(){
    return f()+f()+f()+f();
}
long func2(){
    return 4*f();
}
```
看上去二者行为相同, 且func2调用f1次, 当你写出func1()风格代码时, 你想要优化成为 func2()的样子.

但如果f()的内容是这样呢?

```cpp
long counter = 0;

long f(){
    return counter++;
}
```

该函数具有副作用: 修改全局状态. 改变调用次数会改变程序行为. 大多数编译器不会去判断一个函数有没有副作用, 会**假设最糟的情况**, **保持所有函数调用不变**. 

# 消除循环的低效

## 代码移动

识别要执行多次但计算结果不会改变的计算, 将其移动到代码前面不会被多次求值的部分。比如在for循环条件中的求字符串长度一类的操作。

# 减少过程调用

# 消除不必要内存引用

循环中尽量不要对同一片内存连续进行读写, 会带来大量的内存io, 可以使用一个中间变量代替。 **因为内存别名使用, 编译器往往无法自动完成二种代码的转化.** 

# 循环展开

在两方面改进程序性能: 1. 减少了不直接有助于程序结果的操作的数量(循环索引计算和条件分支) 2. 提供一些方法进一步变化代码, 减少关键路径上的操作数量。

# 提高并行性

有些操作可以被多个功能单元执行, 硬件具有以更高速率执行乘法和加法的潜力, 但是代码不能利用这种能力, 因为我们将累计值放在一个单独变量中, 在之前的计算完成前都不能计算该值。

## 多个累积变量

对于一个可结合可交换的操作(+,*), 可以通过将一组合并运算分割为两个或更多部分, 在最后合并结果提升性能。

## 重新结合变换

可以利用处理器对浮点向量进行运算, 将浮点乘法结合在一起, 提高并行性。


# 书写适用于条件传送的代码

相比于使用`if-else`语句, 使用三元运算符`exp ? a : b`更好一些。

# 总结

1. 高级设计, 为问题选择适当的数据结构和算法

2. 基本编码原则: 消除连续函数调用; 消除不必要内存引用; 

3. 低级优化: 展开循环, 降低开销; 通过使用多个累积变量和重新结合技术; 使用功能型风格重写条件操作. 