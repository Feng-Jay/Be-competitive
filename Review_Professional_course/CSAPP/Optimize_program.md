# 编译器优化的限制
编译器只能对程序进行`安全的优化`, 也就是说优化后的程序和优化前的程序有一样的行为. 要求程序员编写出编译器`能够优化的代码`.

例如:

```cpp
void twiddle1(long* xp, long* yp){
    *xp+=*yp;
    *xp+=*yp;
}
void twiddle2(long* xp, long* yp){
    *xp+= 2* *yp;
}
```
二者似乎有相同的行为, 且似乎`twiddle2`的效率更高一些(3次io:r *xp, r *yp, w *xp), 而前者需要6次io。

但如果`xp==yp`时:

```cpp
//twiddle1
*xp+=*xp;
*xp+=*xp; //xp的值增加4倍
//twiddle2
*xp+=2* *xp; //xp的值增加3倍
```
两个指针可能指向同一内存区域的情况称为`内存别名使用`. 在执行安全的优化中, 编译器无法将其进行从1->2的优化。

**内存别名使用限制了编译器优化的策略**, 第二个妨碍优化的因素是**函数调用**:

```cpp
long f();

long func1(){
    return f()+f()+f()+f();
}
long func2(){
    return 4*f();
}
```
看上去二者行为相同, 且func2调用f1次, 当你写出func1()风格代码时, 你想要优化成为 func2()的样子.

但如果f()的内容是这样呢?

```cpp
long counter = 0;

long f(){
    return counter++;
}
```

该函数具有副作用: 修改全局状态. 改变调用次数会改变程序行为. 大多数编译器不会去判断一个函数有没有副作用, 会**假设最糟的情况**, **保持所有函数调用不变**. 

