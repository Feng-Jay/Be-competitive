# 异常控制流

## 异常

是异常控制流的一种形式, 一部分由硬件实现, 一部分由os实现. 异常即控制流中的突变. 

当处理器监测到有事件发生时, 会通过`异常表`进行一个间接过程调用到专门处理该类事件的os子程序,当处理完成后可能有以下三种情况:

1. 处理程序将控制返回当前指令

2. 处理程序将控制返回下一条指令

3. 处理程序终止被中断的程序


异常需要软硬件密切配合, 系统中每种异常都有一个唯一的非负整数的异常号: 分别由处理器设计者(被零除/缺页/内存访问违例/断点/算术运算溢出)和操作系统内核(系统调用/外部io设备信号)提供。

异常分为四类:

1. 中断(来自io/异步/返回下一条指令)

中断不是由任何一条专门的指令造成的。

2. 陷阱(有意的异常/同步/下一条指令)

陷阱是有意的异常，是执行一条指令的结果。最重要的途径是: 系统调用。

3. 故障(潜在可恢复的错误/同步/可能返回当前指令)

若处理程序可修正该情况，则返回到引起故障的指令，重新执行他/否则就abort

常见的是缺页异常: 指令引用一个虚拟地址，但物理内存并不在内存中，需要从disk读取。

4. 终止(不可恢复的错误/同步/不会返回)

通常是一些硬件错误: DRAM/SRAM位损坏发生的奇偶错误。abort

## 进程

异常是允许os提供进程概念的基本构造块. 

进程的经典定义就是一个执行程序的实例, 系统中每个程序都运行在某个进程的contex中。

fork函数创建的子进程几乎和父进程相同: 用户级虚拟地址空间相同(但独立), 且有相同的文件描述符的copy, 子进程可以读写父进程中打开的任何文件。

特点: 

* fork函数被调用一次, 返回两次: 一次在父进程中(0), 一次是子进程中(子进程pid). 

* 子进程和父进程并发执行的独立进程。内核任意地交替执行指令。

* 相同但独立的地址空间.

* 共享文件

## 回收子进程

一个进程由某种原因终止时，内核并不是直接将其从系统中清除, 而是被保持在一种终止状态中直到被父进程回收。终止但并未被回收的进程称为`zombie`

如果一个父进程终止了, os会安排`init`进程作为其孤儿进程的养父。`init`进程不会终止是所有进程的祖先。

然后是`fork, waitpid, wait, sleep, execve`函数讲解

## 信号

一个信号就是一条消息，通知进程系统中发生了一个某种类型的事件。由于底层的硬件异常是由内核异常处理程序引起的, 对于用户进程不可见, 所以通过信号的机制来通知用户进程发生了什么。

术语:

* 发送信号: 内核通过更新目的进程上下文来发送一个信号。(1. 内核监测到一个系统事件 2. 一个进程调用了kill函数)

* 接受信号: 当目的进程被内核强迫对信号做出反应时就接受了信号, 当然也可以忽略信号/执行一个信号处理程序的user函数捕获这个信号。

一个发出但没有被接受的信号叫做待处理信号。 任何时刻, 一种类型最多只会有一个待处理信号, 如果一个进程有一个类型k的待处理信号, 那么接下来该进程收到的任何k信号都会被直接丢弃掉。

unix系统向进程发送信号的机制都是基于`进程组`这个概念:

每个进程只属于一个进程组, 进程组是一个正整数进程组ID来标识的, 默认一个子进程和其父进程属于一个进程组。

## 非本地跳转

将一个函数转移到另一个当前正在执行的函数, 而不需要经过正常的调用返回序列。通过`setjmp, longjmp函数`实现。



