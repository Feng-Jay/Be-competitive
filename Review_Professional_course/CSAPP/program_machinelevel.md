# 程序的机器级表示

1. 机器级编程的两个重要抽象: ISA定义机器级程序的格式和行为，定义了处理器状态; 指令格式; 每条指令对状态的影响; 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

x86-64的虚拟地址的高16位必须设置为0，所以访问的地址实际能够指定的是2^48范围内的一个byte。

2. x86-64的任何为寄存器生成32bit值的指令都会把寄存器的高位设置为0

3. 加载有效地址指令`leaq`是`movq`的变形, 并不从内存中读数据，而是将有效地址写入目的操作数。可用于做简单的数学运算。

4. x86-64中还维护着一组单个bit的条件码寄存器: CF, ZF, SF, OF

`leaq` 指令不改变任何条件码 `CMP`指令根据两个操作数之间的差来设置条件码并不更新寄存器。`TEST`的行为和`AND`指令行为一样但并不更新寄存器, 常用于两个操作数相同检验正负, 或进行掩码运算。

条件码一般不会直接读取，常用三种方式访问：

* 根据条件码的组合将一个字节设置为0/1 (`SET`指令)

`SET`指令通过对条件码进行操作，对普通寄存器进行赋值。

* 可以条件跳转到其他部分程序

* 可以条件传输数据

5. x86-64的跳转可以分为直接跳转(即跳转的目标是作为指令一部分编码进去的)和间接跳转(跳转目标是从寄存器或内存中读出的)。

`jmp`为无条件跳转,可以为上述两种格式。但**条件跳转必须是直接跳转**。

6. 条件分支的实现可以通过条件控制/条件传送的方式实现

条件控制:即使用有条件和无条件跳转。这种方式简单易懂，但在现代处理器上可能会非常低效。

条件传送: 使用数据的条件转移。它会计算一个条件操作的两种结果,然后根据条件是否满足从中选取一个. 不需要等待预测的结果就可以先执行。

但也会带来**问题**: 1.如果分支需要大量的计算，则会得不偿失 2. 可能会导致空指针等错误风险 3. 有副作用(自增)时也不采用。

7. 分支预测错误的惩罚计算:

```cpp
错误概率为p, 没有预测错误执行需要时间为Tok, 预测错误的处罚是Tmp
Tavg = (1-p)Tok+p(Tok+Tmp) = Tok+pTmp
若已知Tok和Tran(p=0.5时的Tavg), 即 Tran=Tavg(0.5)=Tok+0.5Tmp
Tmp = 2(Tran-Tok)
```

8. 循环的汇编代码

```c++
//do-while
dw_loop: 
    body-statement
    test/cmp
    jxx dw_loop
    rep;ret
//while
1. jump to middle; need -og optimize
loop: 
    body-statement
test:
    t = test-expr
    if(t)
        goto loop

2. grounded-do; need -o1 optimize

t=test-expr
if(!t)
    goto done
loop: 
    body-statement
    t= test-expr
    if(t)
        goto loop
done: 

//for is one format of while loops
//1
init-expr
goto test
loop: 
    body-statement
    update-expr
test:
    t=test-expr
    if(t)
        goto loop
//2
init-expr
t=test-expr
if(!t)
    goto done
loop:
    body-statement
    update-expr
    t=test-expr
    if(t)
        goto loop
done:
```

9. switch语句

通过跳转表来使分支更高效: 执行switch语句的时间和case个数无关。 gcc会根据**case数量**和**case间疏密程度**来判断是否使用跳转表,[something more about it.](https://blog.51cto.com/u_15127644/3879027)

10. 过程

转移控制: `call Q`转移到函数Q, 并将`call`指令后的那条指令的地址压入栈中。`ret`指令会将该地址弹栈, 并将pc设置为该地址。

数据传送: 可通过寄存器传递最多6个参数, 超出的可以通过栈进行传递。最后一个参数先入栈.

栈的局部存储: 有些时候数据必须放在内存中. 比如: 1. 寄存器空间不足 2. 对于局部变量使用`&`, 必须为其生成一个地址。 3. 对于局部变量是数组/结构体, 必须能够通过数组或结构引用被访问到。


**寄存器中的局部存储空间** 寄存器是唯一被所有过程共享的资源。必须保证一个过程调用另一个过程时, 被调用者不会覆盖调用者稍后会使用的寄存器值。`x86-64`采取下面的所有过程必须遵守的惯例:

寄存器`%rbx, %rbp, %r12~%r15`被划分为**被调用者保存寄存器**。过程P调用过程Q时, Q必须保存这些寄存器的值, 保证返回时值和调用时值相同。两种方式: 1. 根本不改变 2. 将旧值压入栈帧, 返回前弹出旧值。 

所有其他的寄存器, 除了栈指针`%rsp`, 都为调用者保存寄存器。 意味着任何函数都能修改他们。

递归过程















<!-- 量化分析: 大概率事件， tradeoff依据

cache

两个步骤: 初赛方案

什么程度可以进决赛？努力方向 ipc/主频，瓶颈分析

流水线结构变化？顺序双发/乱序单发？

决赛问题？对系统移植适配？linux/ucore, 特色？

先有东西再完善，一个突破 -->



