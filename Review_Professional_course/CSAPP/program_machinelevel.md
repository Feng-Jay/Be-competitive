# 程序的机器级表示

1. 机器级编程的两个重要抽象: ISA定义机器级程序的格式和行为，定义了处理器状态; 指令格式; 每条指令对状态的影响; 机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。

x86-64的虚拟地址的高16位必须设置为0，所以访问的地址实际能够指定的是2^48范围内的一个byte。

2. x86-64的任何为寄存器生成32bit值的指令都会把寄存器的高位设置为0

3. 加载有效地址指令`leaq`是`movq`的变形, 并不从内存中读数据，而是将有效地址写入目的操作数。可用于做简单的数学运算。

4. x86-64中还维护着一组单个bit的条件码寄存器: CF, ZF, SF, OF

`leaq` 指令不改变任何条件码 `CMP`指令根据两个操作数之间的差来设置条件码并不更新寄存器。`TEST`的行为和`AND`指令行为一样但并不更新寄存器, 常用于两个操作数相同检验正负, 或进行掩码运算。

条件码一般不会直接读取，常用三种方式访问：

* 根据条件码的组合将一个字节设置为0/1 (`SET`指令)

`SET`指令通过对条件码进行操作，对普通寄存器进行赋值。

* 可以条件跳转到其他部分程序

* 可以条件传输数据

5. x86-64的跳转可以分为直接跳转(即跳转的目标是作为指令一部分编码进去的)和间接跳转(跳转目标是从寄存器或内存中读出的)。

`jmp`为无条件跳转,可以为上述两种格式。但**条件跳转必须是直接跳转**。

6. 条件分支的实现可以通过条件控制/条件传送的方式实现

条件控制:即使用有条件和无条件跳转。这种方式简单易懂，但在现代处理器上可能会非常低效。

条件传送: 使用数据的条件转移。它会计算一个条件操作的两种结果,然后根据条件是否满足从中选取一个. 不需要等待预测的结果就可以先执行。

但也会带来**问题**: 1.如果分支需要大量的计算，则会得不偿失 2. 可能会导致空指针等错误风险 3. 有副作用(自增)时也不采用。

7. 分支预测错误的惩罚计算:

```cpp
错误概率为p, 没有预测错误执行需要时间为Tok, 预测错误的处罚是Tmp
Tavg = (1-p)Tok+p(Tok+Tmp) = Tok+pTmp
若已知Tok和Tran(p=0.5时的Tavg), 即 Tran=Tavg(0.5)=Tok+0.5Tmp
Tmp = 2(Tran-Tok)
```

8. 循环的汇编代码

```c++
//do-while
dw_loop: 
    body-statement
    test/cmp
    jxx dw_loop
    rep;ret
//while
1. jump to middle; need -og optimize
loop: 
    body-statement
test:
    t = test-expr
    if(t)
        goto loop

2. grounded-do; need -o1 optimize

t=test-expr
if(!t)
    goto done
loop: 
    body-statement
    t= test-expr
    if(t)
        goto loop
done: 

//for is one format of while loops
//1
init-expr
goto test
loop: 
    body-statement
    update-expr
test:
    t=test-expr
    if(t)
        goto loop
//2
init-expr
t=test-expr
if(!t)
    goto done
loop:
    body-statement
    update-expr
    t=test-expr
    if(t)
        goto loop
done:
```

9. switch语句

通过跳转表来使分支更高效: 执行switch语句的时间和case个数无关。 gcc会根据**case数量**和**case间疏密程度**来判断是否使用跳转表,[something more about it.](https://blog.51cto.com/u_15127644/3879027)

10. 过程

转移控制: `call Q`转移到函数Q, 并将`call`指令后的那条指令的地址压入栈中。`ret`指令会将该地址弹栈, 并将pc设置为该地址。

数据传送: 可通过寄存器传递最多6个参数, 超出的可以通过栈进行传递。最后一个参数先入栈.

栈的局部存储: 有些时候数据必须放在内存中. 比如: 1. 寄存器空间不足 2. 对于局部变量使用`&`, 必须为其生成一个地址。 3. 对于局部变量是数组/结构体, 必须能够通过数组或结构引用被访问到。


11. **寄存器中的局部存储空间** 寄存器是唯一被所有过程共享的资源。必须保证一个过程调用另一个过程时, 被调用者不会覆盖调用者稍后会使用的寄存器值。`x86-64`采取下面的所有过程必须遵守的惯例:

寄存器`%rbx, %rbp, %r12~%r15`被划分为**被调用者保存寄存器**。过程P调用过程Q时, Q必须保存这些寄存器的值, 保证返回时值和调用时值相同。两种方式: 1. 根本不改变 2. 将旧值压入栈帧, 返回前弹出旧值。 

所有其他的寄存器, 除了栈指针`%rsp`, 都为调用者保存寄存器。 意味着任何函数都能修改他们。

12. 异质数据结构

`struct`: 结构的所有组成部分都存放在内存一片连续区域内。指向其指针为其第一个字节的地址。

`union`: 规避c的类型系统, 使用不同的字段来引用相同的内存块。大小等于最大字段的大小，指针总指向数据结构的起始位置。

可以使用`union`来访问不同数据类型的位模式。例如:

```cpp
unsigned long double2bits(double d){
    union{
        double d;
        unsigned long u;
    }temp;
    temp.d = d;
    return temp.u;
}
```
由于我们之前看到过`IEEE`的浮点数编码情况, 所以u和d的数值间没有任何关系, 除了d=0.0的情况。

且此时字节序就很重要了:

```cpp
double uu2double(unsigned word0, unsigned word1){
    union{
        double d;
        unsigned u[2];
    }temp;
    temp.u[0]=word0;
    tmep.u[1]=word1;
    return temp.d;
}
```
在小端序的机器上面, word0是d的低4位; word1是d的高四位. 但在大端序上面则完全相反。

**端序其实是针对人和机器来说的, 机器内部并没有端序的概念.** 不管是什么机器,都是从低地址向高地址读取数据的. 

只不过大小端机器对数据在内存中放置的位置不同: 大端机将数据低位放在内存高位, 数据高位放在内存低位, 人看到的数据和人的认识一样。

小端机将数据低位放在内存低位, 数据高位放在内存高位, 人看到的数据是和人认知相反的。但其更符合计算机从低地址向高地址读数据的特性。

这里贴出一个[解释](https://www.zhihu.com/question/25311159/answer/33589698):

大端存储因为第一个字节就是高位，从而很容易知道它是正数还是负数，对于一些数值判断会很迅速。而小端存储 第一个字节是它的低位，符号位在最后一个字节，这样在做数值四则运算时从低位每次取出相应字节运算，最后直到高位，并且最终把符号位刷新，这样的运算方式会更高效。

c语言的`enum`枚举类型可用于提高代码可读性。

```c
#include <stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf("%d",day);
    return 0;
}
//output = 3s
```

13. 数据对齐

简化处理器和内存系统间接口的硬件设计, 假设一个处理器总是从内存中取8bytes数据, 如果我们可以保证double类型数据的地址对齐为8的倍数, 那么就可以用一个内存操作来读写其值了。

无论是否对齐其实x86都可以正确工作, 但intel 建议以以下原则进行对齐:

**任何K字节的基本对象的地址必须是K的倍数**

对于结构数据来说需要插入一些空隙来保证对齐。

14. 指针

将指针从一种类型强制转换为另一种类型, 只改变其类型, 而不改变其值。

函数指针: `int (*fp)(int,int*)`为一个指向参数为`int int*`的函数的指针, 可以这样使用:

```cpp
int fun(int x, int* p);

int (*fp)(int, int*);
fp = fun;
//---------------------
int y =1;
int result= fp(3,&y);
```

15. 内存越界&缓冲区溢出

C对于数组引用并不进行边界检查, 且局部变量和状态信息(返回地址, 保存寄存器)都会放在栈中. 因此对于越界数组的的写操作会破坏栈内的其他状态信息。

一种特别常见的叫`缓冲区溢出`, 在栈中分配了字符数组, 但字符串长度超过分配空间. 可能会让程序执行其本不应该执行的函数, 是网络攻击的一种。

对抗缓冲区溢出的方式:

* 栈随机化: 在系统中插入攻击代码, 不仅需要插入代码, 还需要获得指向这段代码的指针. 在之前栈的地址是非常容易预测的. 该方法使得栈的位置在程序每次运行时都有变化。ASLR. 但依旧可以靠蛮力试出, 降低了传播速度, 不保证绝对安全。

* 栈破坏检测: 在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的`金丝雀(canary)值`, 每次随机产生. 在恢复寄存器状态和从函数返回前, 都会检测其是否发生改变. 

* 限制可执行代码区域: 消除攻击者向系统中插入可执行代码的能力. 即**限制哪些内存区域可以存放执行代码**

16. 支持变长栈帧

x86-64使用寄存器`%rbp`作为帧指针, 用于存放初始的栈顶位置。`可以注意到, %rbp是一个被调用者保护寄存器`. 

很有趣的一个题目: P204上面例题, 给一个[解答](https://www.cnblogs.com/czw52460183/p/10390432.html)








<!-- 量化分析: 大概率事件， tradeoff依据

cache

两个步骤: 初赛方案

什么程度可以进决赛？努力方向 ipc/主频，瓶颈分析

流水线结构变化？顺序双发/乱序单发？

决赛问题？对系统移植适配？linux/ucore, 特色？

先有东西再完善，一个突破 -->



